"0",""
"0","balance_check <- function(matched_data, project) {"
"0",""
"0","  required_vars <- c(""treatment"", ""ptal_baseline"", ""imd_baseline"", ""pop_baseline"")"
"0","  missing_vars <- setdiff(required_vars, names(matched_data))"
"0","  "
"0","  if(length(missing_vars) > 0) {"
"0","    cat(""Warning: Missing variables:"", paste(missing_vars, collapse="", ""), ""\n"")"
"0","    return(NULL)}"
"0",""
"0","  balance <- matched_data %>%"
"0","    group_by(treatment) %>%"
"0","    summarise("
"0","      n = n(),"
"0","      ptal = mean(ptal_baseline, na.rm = TRUE),"
"0","      imd = mean(imd_baseline, na.rm = TRUE),"
"0","      pop = mean(pop_baseline, na.rm = TRUE) / 1000,"
"0","      "
"0","      ptal_trend = ifelse(""ptal_trend_long"" %in% names(matched_data),"
"0","                          mean(ptal_trend_long, na.rm = TRUE), NA),"
"0","      imd_trend = ifelse(""imd_trend_long"" %in% names(matched_data),"
"0","                         mean(imd_trend_long, na.rm = TRUE), NA),"
"0","      pop_trend = ifelse(""pop_trend_long"" %in% names(matched_data),"
"0","                        mean(pop_trend_long, na.rm = TRUE), NA),"
"0",""
"0","      dist_mean = ifelse(""dist"" %in% names(matched_data),"
"0","                        mean(dist, na.rm = TRUE), NA),"
"0","      .groups = ""drop"")"
"0","  "
"0","  cat(""\n"", project, ""Matching Balance:\n"")"
"0","  cat(""----------------------------------------\n"")"
"0","  print(balance, n = Inf)"
"0",""
"0","  if(nrow(balance) == 2) {"
"0","    "
"0","    smd_ptal <- abs(diff(balance$ptal)) / sd(matched_data$ptal_baseline, na.rm = TRUE)"
"0","  "
"0","    smd_imd <- abs(diff(balance$imd)) / sd(matched_data$imd_baseline, na.rm = TRUE)"
"0",""
"0","    smd_pop <- abs(diff(balance$pop * 1000)) / sd(matched_data$pop_baseline, na.rm = TRUE)"
"0","    "
"0","    cat(""\nStandardized Mean Differences (SMD):\n"")"
"0","    cat(""  PTAL:"", round(smd_ptal, 3))"
"0","    if(smd_ptal > 0.25) cat("" ⚠️"")"
"0","    cat(""\n"")"
"0","    "
"0","    cat(""  IMD:"", round(smd_imd, 3))"
"0","    if(smd_imd > 0.25) cat("" ⚠️"")"
"0","    cat(""\n"")"
"0","    "
"0","    cat(""  Population:"", round(smd_pop, 3))"
"0","    if(smd_pop > 0.25) cat("" ⚠️"")"
"0",""
"0","    if(!is.na(balance$ptal_trend[1]) && ""ptal_trend_long"" %in% names(matched_data)) {"
"0","      smd_ptal_trend <- abs(diff(balance$ptal_trend)) / "
"0","                       sd(matched_data$ptal_trend_long, na.rm = TRUE)"
"0","      cat(""  PTAL trend:"", round(smd_ptal_trend, 3))"
"0","      if(smd_ptal_trend > 0.25) cat("" ⚠️"")"
"0","      cat(""\n"")}"
"0","    "
"0","    if(!is.na(balance$imd_trend[1]) && ""imd_trend_long"" %in% names(matched_data)) {"
"0","      smd_imd_trend <- abs(diff(balance$imd_trend)) / "
"0","                      sd(matched_data$imd_trend_long, na.rm = TRUE)"
"0","      cat(""  IMD trend:"", round(smd_imd_trend, 3))"
"0","      if(smd_imd_trend > 0.25) cat("" ⚠️"")"
"0","      cat(""\n"")}"
"0","    "
"0","    cat(""\nBalance Assessment:\n"")"
"0","    if(smd_ptal < 0.1 && smd_imd < 0.1 && smd_pop < 0.1) {"
"0","      cat(""✓ Excellent balance (all SMD < 0.1)\n"")"
"0","    } else if(smd_ptal < 0.25 && smd_imd < 0.25 && smd_pop < 0.25) {"
"0","      cat(""○ Acceptable balance (all SMD < 0.25)\n"")"
"0","    } else {cat(""✗ Poor balance (some SMD > 0.25)\n"")}"
"0","    "
"0","    return(invisible(list("
"0","      smd_ptal = smd_ptal,"
"0","      smd_imd = smd_imd,"
"0","      smd_pop = smd_pop,"
"0","      balance_table = balance)))"
"0","    "
"0","  } else {cat(""\nWarning: Cannot calculate SMD - need exactly 2 groups\n"")"
"0","    return(NULL)}}"
"0",""
"0","nle_balance <- balance_check(nle_matched, ""NLE"")"
"1","
"
"1"," "
"1","NLE"
"1"," "
"1","Matching Balance:
"
"1","----------------------------------------
"
"1","Simple feature collection with 2 features and 9 fields"
"1","
"
"1","Geometry type: GEOMETRY
"
"1","Dimension:     XY
"
"1","Bounding box:  "
"1","xmin: 525107.7 ymin: 171888 xmax: 535530.4 ymax: 182273.9"
"1","
"
"1","Projected CRS: OSGB36 / British National Grid
"
